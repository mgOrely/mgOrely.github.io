---
layout: post
title: "go的并发机制"
description: "go的并发机制"
keywords: "go,并发"
category: "golang"
tags: [go,并发]
---

## 4. go的并发机制
	4.1 原理探究
		4.1.0 综述
			两级线程模型
			用共享内存的方式来通信
				原理
					把数据放在共享内存中以供多个线程访问
				优点
					基本思想很简单
				缺点
					并发访问控制复杂
					正确性：需要做各种约束和限制
					可伸缩性：同步方法，降低了可伸缩性
			以通信作为手段来共享内存
				工具
					channel
					作用
						在多个goroutine之间传递数据
						保证整个过程的并发安全性
			并发机制的概念
				用于支撑goroutine和channel的底层原理
					两级线程模型
					调度器的主要调度流程
		4.1.1 线程实现模型
		    0. 综述
		        3个核心元素
		            M:matchine。内核线程，工作线程；
		            P:processor。上下文环境；
		            G:goroutine。Go代码片段的封装。
		        3个核心元素之间的联系
		            一个G的执行需要P和M的支持；
		            内核线程M+上下文环境P=有效的G运行环境；
		            每个P包含一个可运行的G的队列，一对多；
		            队列中的G会被依次传递给与本地P关联的M，并获得运行的时机；
		            M和P相互引用；
		        概念
		            当前M:运行当前G的那个M；
		            本地P:与当前M关联的那个P；
		        3个核心元素与内核调度实体（KSE）之间的关系
		            M与KSE之间总是一一对应的关系
		                一个M能且仅能代表一个内核线程；
		                Go的运行时系统用M代表一个内核调度实体；
		                M与KSE之间的关联非常稳固；
		                一个M在其生命周期内，会且仅会与一个KSE产生关联
		            M与P、P与G之间的关联都是易变的
		                它们之间的关系会在实际调度的过程中改变；
		            M与P之间也总是一对一的；
		                个人理解：
		                    在同一时刻是一对一；
		                    在整个调度过程中看，是多对多，与M关联的P和与P关联的M会发生变化；		               		            
		            P与G之间则是一对多的关系；
		            M与G之间也会建立关联
		                因为一个G终归会由一个M来负责运行；
		                它们之间的运行会由P来牵线；        
		    1. M
		        什么时候会创建新M?
		            大多数情况：没有足够的M来关联P并运行其中可运行的G；
		            运行时系统执行系统监控或垃圾回收等任务的时候；
		        M结构中的字段
		            g0
		                带有调度堆栈的goroutine；
		                表示一个特殊的goroutine；
		                这个goroutine是Go运行时系统在启动之初创建的，用于执行一些运行时任务；
		            mstartfn
		                表示M的起始函数；
		                这个函数就是我们在编写go语句时携带的那个函数；
		            curg
		                当前运行的goroutine；
		                存放当前M正在运行的那个G的指针；
		            p
		                用于执行Go代码的附加P（如果不执行Go代码，则为零）；
		                字段p的值指向与当前M相关联的那个P。
		                关系：mstartfn,curg,p最能体现当前M的即时情况。
		            nextp
		                暂存与当前M有潜在关联的P；
		                概念：
		                    对M和P的预联：调度器将某个P赋给某个M的nextp字段的操作； 
		                主要作用：运行时系统有时候会把刚刚重新启用的M和已与它预联的那个P关联在一起。       
		            spinning      
		                M失业了，正在积极寻找工作；
		                用于表示这个M是否正在寻找可运行的G。
		                字段名的由来：在寻找过程中，M会处于自旋状态；
		            lockedg
		                Go运行时系统可以把一个M和一个G锁定在一起；
		                一旦锁定，这个M就只能运行这个G，这个G也只能由该M运行；
		                锁定和解锁的具体方法：LockOSThread()和UnLockOSThread()     
                        表示与当前M锁定的那个G（如果有的话）； 
                M创建之初
                    M为执行G做准备
                        被加入全局的M列表（runtime.allm）中；
                        起始函数和预联的P被设置；
                        运行时系统为这个M专门创建一个新的内核线程并与之相关联；
                    细节：
                        起始函数的设置时机：仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置；
                        全局M列表
                            没有什么特殊的意义；
                            运行时系统在需要的时候，会通过它获取到所有M的信息；
                            可以防止M被当作垃圾回收掉；
                新M被创建之后
                    Go运行时系统会对它进行一番初始化
                        包括对自身所持的栈空间以及信号处理方面的初始化                
		            初始化工作完成后，M的起始函数会执行（如果存在的话）；
		                如果这个起始函数代表的是系统监控任务：那么该M会一直执行它，而不会继续后面的流程； 
		                否则，在起始函数执行完毕后，当前M将会与那个预联的P完成关联，并准备执行其他任务；
		                    M会依次在多处寻找可运行的G并运行之；
		                    这一过程的重要性：
		                        是调度的一部分；
		                        有了M，Go程序的并发运行基础才得以形成；
		        M的停止
		            时机：在运行时系统执行垃圾回收任务的过程中；
		            过程：运行时系统在停止M的时候，会把它放入调度器的空闲M列表（runtime.sched.midle）
		            重要性：
		                在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取；
		                M是否空闲，仅以它是否存在于调度器的空闲M列表中为依据；                   
		        单个Go程序所使用的M的最大数量
		            含义：
		                最理想的情况
		                    一个Go程序最多可以使用的M的数量；
		                    最多可以有多少个内核线程服务于当前的Go程序。
		                 实际情况
		                    操作系统内核对进程的虚拟内存的布局控制以及大小限制，如此量级的线程可能很难共存；
		                    Go本身对于线程数量的限制几乎可以忽略；		                       
		            初始设置
		                Go程序运行的时候会先启动一个引导程序，这个引导程序会为其运行建立必要的环境；
		                初始化调度器的时候，它会对M的最大数量进行初始设置，这个初始值是10000。		              
		            自定义设置
		                在Go程序中对该限制进行设置；
		                    调用标准库代码包runtime/debug中的SetMaxThreads函数，并提供新的M最大数量；
		                        runtime/debug.SetMaxThreads()函数在执行完成后，会把旧的M最大数量作为结果值返回；
		                    新值的设定
		                        谨慎使用这个函数；    
		                        如果调用runtime/debug.SetMaxThreads()函数时给定的新值比当时M的实际数量小，运行时系统就会立即引发一个运行时恐慌；
		                        如果真的需要设置M的最大数量，越早调用该函数越好；
		                        对于它的设定值，需要仔细斟酌。
		    2. P
		        重要性
		        作用机制概述
		        单个Go程序间接拥有的P的最大数量
		            初始设置
		            自定义设置：两种方法
		                方法一：调用函数runtime.GOMAXPROCS
		                    什么时候调用?
		                    调用该函数的副作用：损耗程序性能；
		                        过程：所有P脱离运行状态，重整全局的P列表，
		                        重整全局P列表
		                            重要前提：取出P中的可运行G，放入调度器的可运行G队列；
		                            P在被清空可运行G队列之后，被放入空闲P列表；		                            		                   
		                方法二：设置环境变量GOMAXPROCS
		                    什么时候设置                                                             
		            作用过程
		                引导程序初始化调度器
		                判断环境变量GOMAXPROCS的值
		                检查该值的有效性：硬性上限值
		                    
		        最大数量
		            P的数量
		                含义
		                最大数量的含义
		            M的数量
		            G的数量
		        作用机制详解
		            等待运行时机        
		            M与P关联
		            M与P分离
		            空闲M或新M，与P关联                           
		        P可能具有的状态
		            5个
		            状态的含义
		            什么情况下处于该状态
		            P在各个状态之间进行流转
		                状态转换图
		                解读
		        P结构中最重要的两个成员
		            可运行G队列        
		            自由G列表
		                包含的元素
		                作用机制
		            重要性    
		    3. G
		        含义
		        参与人：编程人员，编译器，Go的运行时系统
		        递送并发任务的方法
		        G的全局列表
		            作用
		        并发任务的执行过程
		            编译器
		            运行时系统
		                检查合法性
		                获取G
		                初始化G
		                将G存于某地
		                    P的runnext字段
		                    P的可运行G队列的末尾
		                    调度器的可运行G队列的末尾
		        G的状态
		            7+1个
		            组合状态
		            含义
		            状态之间的流转 
		            解读
		            Gdead和Pdead含义的区别                                        
		    4. 核心元素的容器
		        3个全局容器
		        与G相关的4个非全局容器
		            两个可运行G列表中的G
		                运行机会
		                存放位置和条件
		                    状态流转过程中
		                    两个可运行G队列之间也会相互转移G 
		                调度器的可运行G队列                                   
	                自由G列表
	                    调度器的自由G列表
	                        2个
	    4.1.2 调度器
	        1. 基本结构                    