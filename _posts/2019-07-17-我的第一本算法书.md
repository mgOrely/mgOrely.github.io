---
layout: post
title: "书籍　我的第一本算法书"
description: "我的第一本算法书"
keywords: "书籍,算法"
category: "algorithm"
tags: [书籍,数据结构,算法]
---

## I 前言
这本书背后的app-算法动画图解；


## II 介绍

* 书名：我的第一本算法书
* 作者：宫崎修一 石田保辉
* 出版时间：2018-10

## III 阅读
* 阅读平台：微信读书（491页）
* 开始时间：2019-07-17
* 结束时间：2019-07-20
* 阅读时长：14小时13分钟
* 感受：平实易懂，举例+图示；页面好看；

## IV 笔记

算法的时间复杂度的计算；

### 1. 数据结构：
#### 1. 什么是数据结构
- 数据的顺序和位置；

#### 2. 链表；
- 特点；
- 操作：添加，删除；访问：
- 操作的运行时间；
- 单链表，
- 循环链表（环形链表），使用场景；
- 双向链表，优点，缺点；

#### 3. 数组：
- 概念：数组下标；
- 操作：访问，添加，删除
- 操作的运行时间；
- 跟链表互补：
- 链表是访问复杂，添加和删除简单；
- 数组是访问简单，添加和删除复杂；
- 决定使用哪种数据结构的依据：哪种操作较为频繁

#### 4. 栈
- 特点：
- 举例：
- 概念图：
- 概念：入栈，出栈
- 使用场景：只需要访问最新数据；
- 应用：匹配括号，深度优先搜索算法的候补顶点的管理


#### 5. 队列
- 特点：
- 概念图；
- 概念：入队，出队；
- 操作：删除，添加；
- 应用：广度优先搜索算法的候补顶点的管理

#### 6. 哈希表
- 存储的数据；
- 概念：冲突；
- 举例，人名和性别；
- 结构：数组+链表；
- 构造过程：
    - 确定数组的长度；
    - 通过hash函数计算key的哈希值；
    - 将哈希值对数组长度求余，余数就是数组的下标；
    - 存储位置重复，使用链表；
- 解决冲突的方法：
- 链地址法；
- 开放地址法；
- 操作：查找；

#### 7. 堆
- 概念：堆，结点，优先队列；
- 示例；
- 特点：
    - 结点；
    - 数的形状；
    - 结点的排列顺序；
    - 存储数据的规则；
- 操作：添加，取出；
- 应用：需要频繁取出最小值；狄克斯特拉算法；

#### 8. 二叉查找树
- 别名；
- 概念；
- 结构；
- 示例图；
- 2个性质；
- 操作：添加，删除；查找；
- 关联：二分查找算法
- 扩展：平衡二叉查找树，B树

### 2. 排序
#### 1. 什么是排序
- 概念：排序；
- 举例；
- 图示；

#### 2. 冒泡排序
- 概念；
    - 基本操作：从序列右边开始，比较相邻两个数字的大小，再根据结果交换两个数字的位置；
- 图示过程；
- 解说：
    - 分析排序过程；
    - 比较次数，交换次数，和输入数据的排列顺序的关系；极端情况
    - 时间复杂度；

#### 3. 选择排序
- 概念；
    - 基本操作：从待排序的数据中寻找最小值（线性查找），将其与序列最左边的数字进行交换；
- 图示过程；
- 解说：
    - 分析排序过程；
    - 比较次数，交换次数；极端情况
    - 时间复杂度；
    
#### 4. 插入排序
- 概念：
    - 基本操作：从序列左端开始，依次对数据进行排序；
- 图示过程；
- 解说：
    - 分析排序过程；
    - 比较次数，交换次数；极端情况
    - 时间复杂度；
    
#### 5. 堆排序
- 概念；
- 图示过程；
    - 将数据存储到堆中，按照降序构建堆；
    - 从堆中取出数据，反序输出；
- 解说：
    - 分析排序过程；
    - 插入，取出，重构；
    - 时间复杂度；
    - 数组和堆；
    
#### 6. 归并排序
- 概念：
    - 归并；
- 图示过程；
    - 两两归并
    - 含有多个数字的子序列，比较首位，移动较小；
    - 递归执行；
- 解说：
    - 不考虑分割序列所花费的时间；
    - 过程：比较，移动，合并；
    - 时间复杂度；
    
#### 7. 快速排序
- 思想：
    - 随机选择基准值；
- 图示过程；
    - 随机选择基准值，对基准值左右两边的序列分别进行快速排序；
- 补充说明
    - 分治法；
    - 递归
- 解说：
    - 跟归并排序和选择排序的关系；
    - 时间复杂度；

### 3. 数组的查找
#### 1. 线性查找
- 思路；
- 图示过程；
    - 迭代，比较；
- 解说：
    - 时间复杂度；
    
#### 1. 二分查找
- 思路；
- 条件：
    - 排好序的数据；
- 图示过程；
    - 找到中间的数字，比较，移出；重复；
- 解说：
    - 时间复杂度；
- 补充说明
    - 选择哪种查找方法，根据查找和添加哪个更频繁来决定；

### 4. 图的搜索
#### 1. 什么是图
- 概念：
    - 顶点，边，图；权重，加权图；有向图，非对称权重；图的搜索；
- 图示；
- 应用；
- 思考：
    - 实际应用：用于规划出行路线；票价最低，时间最短；

#### 2. 广度优先搜索
- 思路；
- 图示：
    - 候补顶点的选择和管理（队列）；
- 解说：
    - 特征
- 补充说明：
    - 树的概念；    

#### 3. 深度优先搜索
- 思路；
- 图示：
    - 候补顶点的选择和管理（栈）；
- 解说：
    - 特征；
    - 和广度优先搜索比较；

#### 4. 贝尔曼-福特算法
- 概念：
    - 最短路径问题；
- 图示：
    - 设置顶点的初始权重
    - 选择一条边，计算从一端到另一端的权重，按顶点权重从小到大的方向：顶点权重+边的权重；
    - 计算结果小于顶点的值，更新顶点的权重；记录该权重对应的顶点；
    - 重复所有边，完成第一轮更新；
    - 重复以上步骤，直到权重不能被更新为止；
- 解说：
    - 顶点n，边m；
    - 时间复杂度
    - 有向图的情况；    
- 补充说明
    - 权重是负数的情况；
    - 不存在最短路径：闭环中有负数权重；
    - 与狄克斯特拉算法的比较；
- 小知识；
    - 算法名称的由来；
    - 动态规划；        
- 疑问：
    - 该算法经过n轮更新操作后就会停止。为什么是n轮？    

#### 5. 狄克斯特拉算法
- 概念；
- 图示：
    - 设置顶点的初始权重；
    - 确定候补顶点：可以从当前顶点直达且尚未被搜索过的顶点；
    - 计算各个候补顶点的权重：当前顶点权重+边的权重；
    - 计算结果小于候补顶点的值，更新候补顶点的权重；
    - 移动到权重最小的候补顶点；
    - 重复以上过程，直到到达目标顶点；
- 小知识；
    - 算法名称的由来；
    - 图灵奖；
- 解说：
    - 顶点n，边m；
    - 时间复杂度
    - 与贝尔曼-福特算法的比较；  
- 补充说明
    - 有向图；
    - 含有负数权重，可能无法得出正确答案；


#### 6. A*算法
- 思路
    - 狄克斯特拉算法发展而来；
    - 狄克斯特拉算法的冗余计算；
- 图示：
    - 用狄克斯特拉算法求迷宫中的最短路径；
    - 从起点到终点的估算距离=当前顶点到起点的实际距离+当前顶点到终点的距离估算值；
    - 选择权重最小的顶点，设置为搜索完毕状态；
    - 计算搜索完毕的顶点到下一个顶点的权重；
    - 重复上述操作，直到到达终点；
    - 跟狄克斯特拉算法比较：基本不会去计算离终点较远的区域；
- 提示；
    - 概念：距离估算值；
- 解说：
    - 使用前提 
    - 距离估算值的设定
- 应用
    - 游戏编程
    - 计算量较大
    
### 5. 安全算法
#### 1. 安全和算法
- 安全技术存在的必要性
- 数据传输时的四个问题：
    - 窃听
    - 假冒
    - 篡改：消息内容变化的原因之一；
    - 事后否认，谁否认，导致的问题；
- 以上问题发生时机
- 解决这些问题的安全技术
    - |问题|解决方法|
      |---|---|
      |窃听|加密|
      |假冒|消息认证码or数字签名|
      |篡改|消息认证码or数字签名|
      |事后否认|数字签名|
    - 数字签名技术
        - 存在的问题
        - 解决方案  
        
#### 2. 加密的基础知识
- 提出问题：加解密时，计算机是如何处理的？
- 图示
    - 概念：密文，解密
- 解说
    - 加密的具体操作：二进制；
    - 概念：数据，密文；加密，密钥，解密，加密技术；  
      
#### 3. 哈希函数
- 作用
- 应用：数据摘要
- 图示
    - 比喻：搅拌机；
    - 概念：十六进制，哈希值，哈希冲突；
    - 哈希函数的四个特征
        - 哈希值数据长度不变；
        - 输入相同，输出相同；
        - 输入相似，输出不相似；
        - 输入不同，输出可能相同；
        - 输入输出不可逆；
        - 计算容易；
- 解说
    - 哈希函数的3个具有代表性的算法
    - 3种算法的比较；
- 应用
    - 基于密码的用户认证               

#### 4. 共享密钥加密
- 加密数据的两种方法
- 概念：
- 别名
- 图示流程；
- 小知识
    - 实现算法：凯撒密码，AES，DES，动态口令；
- 问题
    - 密钥被窃听
- 解说
    - 概念：密钥分配问题；
    - 解决方案：密钥交换协议，公开密钥加密；
- 小知识
    - 故事：二战，德军，恩尼格玛密码机，Enigma，一个月的密钥记录成表格进行交接，解决了密钥分配的问题；
    - 恩尼格玛密码机的弱点：密文周期性出现相同的文字；艾伦-图灵破译；
    - 现在的加密算法解决了上述问题，即便连续发送相似的文字，也难以破解       

#### 5. 公开密钥加密
- 概念
    - 公开密钥加密
    - 公开密钥
    - 私有密钥
- 别名
- 图示流程
    - 1.接收方生成公开密钥和私有密钥；
    - 2.接收方把公开密钥发给发送方；
    - 3.发送方用公开密钥加密数据，发送给接收方；
    - 4.接收方使用私有密钥解密；
    - 公开密钥加密优于共享密钥加密的地方：
        - 不会出现密钥分配问题；
        - 适用于多人传输数据；举例；
        - 安全性更高：接收方保管私有密钥；
    - 存在的问题：
        - 1.公开密钥的可靠性；
            - 举例；
            - 概念：中间人攻击
            - 解决方案：数字证书
        - 2.耗时
            - 解决方案：选择使用场景，避免持续发送零碎数据的情况；混合加密         
- 提示
    - 实现公开密钥加密的算法：
        - RSA算法；名称的由来；图灵奖
        - 椭圆曲线加密算法；    
    - 共享密钥加密时，密钥的需求数量
- 解说
    - 实现算法需要满足的三个条件：
        - 1.可以使用某个数值对数据进行加密；
        - 2.用另一个数值对加密数据进行计算可以让数据恢复原样；
        - 3.无法从一种密钥推算出另一种密钥；   
    - RSA算法的意义；    

#### 6. 混合加密
- 概念
- 思路
    - 数据：共享密钥加密
    - 共享密钥：公开密钥加密
- 图示流程
    - 1.接收方生成公开密钥和私有密钥；
    - 2.接收方把公开密钥发送给发送方；
    - 3.发送方使用收到的公开密钥加密共享加密中需要使用的密钥；
    - 4.发送方将加密后的共享密钥和数据发送给接收方；
    - 5. 接收方用私有密钥解密共享密钥，再用共享密钥解密数据；
- 解说
    - 优势：安全性，处理速度
    - 应用举例：SSL/TLS 
                 
#### 7. 迪菲-赫尔曼密钥交换
- 概念
- 思路
- 图示
    - 合成密钥；
        - 合成方法的三个特征
            - 1.密钥之间可以合成，但不能分解；
            - 2.合成后的密钥还可以继续合成；
            - 3.密钥的合成结果与合成顺序无关，只与用了哪些密钥有关
    - 密钥交换流程
        - 1.A生成密钥P；
        - 2.A把P发送给B;
        - 3.A和B各自有一个私有密钥SA和SB;
        - 4.A将P和SA合成新的密钥P-SA;B将P和SB合成新的密钥P-SB;
        - 5.A将P-SA发送给B；B将P-SB发送给A;
        - 6.A将SA和P-SB合成新的密钥SA-P-SB;B将SB和P-SA合成新的密钥SB-P-SA;
    - 验证该密钥交换的安全性
        - 需要在互联网上传输的密钥：P,P-SA,P-SB;
        - 即使被窃听，也无法合成P-SA-SB；
    - 公式
        - 概念：素数，生成元（原根）
        - 用公式表示：
            - 1.A生成密钥P：素数P和生成元G;
            - 2.A把P（素数P和生成元G）发送给B;
            - 3.A和B各自有一个私有密钥SA（X）和SB（Y）;X和Y都小于P-2；
            - 4.A将P和SA合成（计算G的X次方mod P）新的密钥P-SA;B将P和SB合成（计算G的Y次方mod P）新的密钥P-SB;
            - 5.A将P-SA发送给B；B将P-SB发送给A;
            - 6.A将SA和P-SB合成（计算（G的X次方mod P）的Y次方mod P=G的XY次方mod P）新的密钥SA-P-SB;B将SB和P-SA合成（计算（G的Y次方mod P）的X次方mod P=G的XY次方mod P）新的密钥SB-P-SA;     
         - 验证安全性
            - 窃听者无法用窃听到的数字计算出A和B共有的数字；？共有数字不就是P和G么
            - 窃听者无法计算出保密数字X和Y;          
- 解说
    - 提出者；2015图灵奖
    - 离散对数问题：根据素数P，生成元G，和（G的X次方mod P）求出X的问题；
    - 至今未找到这个问题的解法；
- 补充说明
    - 方法的本质：交换公开信息，生成密钥；
    - 别名；                    

#### 8. 消息认证码
- 2个功能
- 概念
- 图示举例，什么情况下需要使用消息认证码；
    - 正常流程：
        - A使用公开密钥加密或迪菲-赫尔曼密钥交换协议，交换密钥；
        - A使用共享密钥加密；
        - A发送密文；
        - B解密密文；
    - 可能会发生的情况：
        - 密文被篡改；
        - 接收者没有意识到篡改，解密后的消息不对；
    - 解决方案：消息认证码
        - A生成一个用于制作消息认证码的密钥，使用安全的方法将密钥发送给B;
        - A使用密文和密钥生成一个值（消息认证码MAC）;
        - A将密文和MAC发送给B;
        - B使用密文和密钥生成MAC,跟A发来的对比，一致则确认消息未被篡改；
        - B使用密钥解密密文；
    - 验证可行性
        - X对密文进行篡改；
        - B计算MAC跟A发来的不一致；废弃收到的密文和MAC；向A提出再次发送的请求；    
- 提示
    - 类比：MAC，哈希值
    - 计算MAC的算法：HMAC，OMAC，CMAC； 
- 解说
    - 加密，解密的本质；
    - 为什么需要消息验证码；
- 补充说明
    - 验证X对密文和MAC都进行篡改的情况；
        - X没有计算MAC的密钥，篡改了MAC，也无法让篡改后的密文变得合理；
    - 缺点  
        - 存在事后否认问题：因为AB都持有加密消息的密钥和计算MAC的密钥；
        - 解决方案：数字签名；            

#### 9. 数字签名
- 3个功能
- 图示
    - 数字签名的特征
        - 1.数字签名只能由发送者生成；
        - 2.只要发送的消息上有数字签名，就能确定消息的发送者；
        - 3.接收者可以验证数字签名的正确性，但无法生成数字签名；
    - 数字签名的生成
        - 公开密钥加密
        - 使用数字签名的消息交换流程
            - 发送者准备好需要发送的消息，私有密钥，公开密钥；
            - 发送者将公开密钥发送给接收者；
            - 发送者使用私有密钥加密消息（数字签名的概念：被私有密钥加密后的消息）；
            - 发送者将消息和签名都发送给接收者；
            - 接收者使用公开密钥对密文（签名）进行解密，对比解密后的消息和收到的消息是否一致；
- 解说
    - 数字签名的特点：
        - 只能由持有私有密钥的发送者来加密，但只要有公开密钥，谁都可以解密；
    - 数字签名的机制 
        - 用私有密钥生成签名，用公开密钥验证签名
    - 数字签名和公开密钥加密的对比：
        - 公开密钥加密：用公开密钥加密的数据，用私有密钥还原；
        - 数字签名：用私有密钥加密的数据，用公开密钥还原；
        - 性质：
            - 即使密钥的使用顺序不同，运行结果也都是一样的；
        - 具有这个性质的算法：
            - RSA加密算法
- 补充说明
    - 签名的实际应用：
        - 先求消息的哈希值，再对哈希值进行私有密钥加密
        - 原因：公开密钥加密和解密都比较耗时，为了节约运行时间
    - 缺陷
        - 存在冒充问题；
        - 根本原因：无法确定公开密钥的制作者是谁；
    - 解决方案
        - 数字证书          
                
#### 10. 数字证书
- 功能
    - 保证公开密钥的正确性
- 图示流程
    - 1.发送方持有公开密钥PA和私有密钥SA；
    - 2.A向认证中心（CA）申请发行证书，证明公开密钥PA确实由自己生成；
        - A将公开密钥PA和包含邮箱信息的个人资料发送给认证中心；
        - 认证中心持有公开密钥PC和私有密钥SC；
        - 认证中心对收到的资料进行确认，判断是否为A本人的资料
        - 认证中心使用自己的私有密钥SC，根据A的资料生成数字签名；
        - 认证中心将生成的数字签名和资料放进同一个文件（该文件就是A的数字证书）；
        - 认证中心将该文件发送给A；
    - 3.A将作为公开密钥的数字证书发送给B;
    - 4.B收到数字证书后，确认证书里的邮件地址确实是A的地址；
    - 5.B获取认证中心的公开密钥PC，对证书内的签名进行验证，判断确实是认证中心给的签名；
    - 6.B从证书中取出A的公开密钥。
    - 验证公开密钥的交付过程
        - X冒充A，向B发送公开密钥PX；B不信任以非证书形式收到的公开密钥；
        - X只能用自己的邮箱地址去申请证书，获取不了A的证书；  
- 提示
    - 认证中心
        - 职能：管理数字证书
        - 谁可以成为认证中心？
            - 任何人
        - 认证中心的数量
            - 比较多
        - 认证中心的选择
            - 经过政府审查的大型企业机构
- 解说
    - 公开密钥问题
        - 公开密钥自身不能表示其制作者；
    - 解决方案
        - 树结构：上面的认证中心为下面的认证中心发行证书
        - 树结构的形成：通过大型组织对小组织的信赖担保；
            - A:被社会广泛认可的认证中心；B:刚成立的公司，想要开展认证中心的业务；B向A申请发行数字证书；
            - A对B进行检测，能否开展认证中心业务；
            - A向B发行证书；
            - B向社会表示自己获得了A的信任；
        - 根认证中心
            - 概念：
                - 根认证中心：最顶端的认证中心，自己证明自身的正当性；
                - 根证书：对根认证中心自身进行证明的证书；
            - 形态：多为大型企业，或者与政府关联且已经取得了社会信赖的组织；    
- 补充说明
    - 个人之间和网站之间交付公开密钥的对比：
        - 个人
            - 个人的证书与邮箱信息相对应
        - 网站
            - 收到来自网站的含有公开密钥的证书，确认该网站未被冒充；
            - 概念：服务器证书
            - 服务器证书与域名信息相对应
            - 确认网站域名和存储网站本身内容的服务器由同一个组织来管理；
    - 数字证书的机制
        - 通过认证中心来担保公开密钥的制作者        
    - 概念
        - 公钥基础设施（PKI）
        
### 6. 聚类
#### 1. 什么是聚类
- 概念
    - 聚类
    - 簇
    - 相似
    - 差距
- 图示示例 
- 举例
- 聚类的过程
    - 定义好数据间的差距
    - 确定聚类的目的
    - 设定聚类的条件   
    
#### 2. k-means算法
- 概念
- 图示举例
    - 1.准备：需要聚类的数据，决定簇的数量3；
    - 2.随机选择3个点作为簇的中心点；
    - 3.计算各个数据分别和3个中心点中的哪一个点距离最近，将数据分到相应的簇中；
    - 4.计算各个簇中数据的重心，然后将簇的中心点移动到这个位置；
    - 5.重复步骤3,4，直到中心点不再发生变化；
- 解说
    - 数学层面
        - 随着操作的不断重复，中心点的位置必定会在某处收敛；
    - 聚类结果跟什么2个因素有关：
        - 簇的数量
        - 中心点最初的位置 
- 补充说明
    - 其他聚类算法
        - 层次聚类算法
        - 与k-means算法的区别：不需要事先设定簇的数量；
        - 思路
            - 一开始每个数据自成一类，有n个数据，就有n个簇；
            - 将距离最近的两个簇合并为一个，重复n-1次；  
                - 每执行一次，簇就减少一个；
                - 执行n-1次后，所有数据都被分到一个簇中；
                - 每个阶段的簇的数量都不同，对应的聚类结果也不同；
                - 选择其中最为合理的一个结果；
        - 算法分类，根据对簇之间的距离进行定义的方法不同
                - 最短距离法
                - 最长距离法
                - 中间距离法
                           
### 7. 其他算法
#### 1. 欧几里得算法
- 别名
- 作用
- 声誉
- 发现时间
- 图示举例：求两个数的最大公约数
    - 通常做法
        - 对两个数字因式分解
        - 找出共同的素数
        - 求出最大公约数
        - 难点
        - 数字越大，因式分解越难
    - 欧几里得算法的操作流程
        - 1.用较小的数字去除较大的数字，求出余数
        - 2.用除数和余数进行mod运算；
        - 3.重复步骤2，直到余数为0，此时的除数就是两数的最大公约数
    - 欧几里得算法的原理
        - 假设最大公约数为n，那么每次的被除数，除数和余数都是n的整数倍；      
- 解说
    - 优势
        - 即使两个数字再大，重复做除法就能高效地求得两者的最大公约数；
        
#### 2. 素性测试
- 概念
    - 素性测试
    - 素数
- 应用
    - RSA算法
- 举例
    - 判断一个数是否为素数
    - 简单的方法：
        - 将该数按顺序除以比2大的数，看是否能被整除；
        - 计算该数的平方根，除以从2到平方根的数字
        - 缺点：数非常大，该方法十分耗时；
        - 解决方案：费马测试
    - 费马测试
        - 别名：概率性素性测试；
        - 功能：判断某个数是素数的概率大不大；
        - 素数的性质：
            - 对于任意素数p，小于p的所有自然数n,n的p次方mod p=n
            - 费马小定理
            - 费马测试的定义：根据是否满足费马小定理来判断一个数是否为素数的方法；
- 解说
    - 需要判断的数为素数的可能性
        - 确认n和余数一致的次数越多，可能性就越大
        - 每一个小于p的数都去计算，非常耗时；
        - 确认几组n和余数，就可以大致判定该数是素数；
    - 费马测试的改进：米勒-拉宾素性测试
        - 当数不是素数的概率小于0.5的80次方时，就可以大致判断该数为素数； 
- 补充说明
    - 素性测试公式的不严谨性
        - 如果p是素数，那么所有比p小的数n都满足n^p mod p =n这个条件；
        - 即使所有n都满足条件，p也有可能不是素数；
    - 概念
        - 合数：非素数的自然数
        - 卡迈克尔数
            - 概念：所有n都满足n^p mod p =n这个条件的合数
            - 别名
            - 举例
- 小知识
    - 在输入规模的多项式时间内进行素性测试
        - 概率意义上的：
            - 费马测试
                - 实用性:高速，应用范围更广泛
        - 决定性的
            - ASK算法
                - 命名
                - 时间和国籍：2002年，印度
            - 该算法的实用性；
                - 计算次数仍然较多                                         
            
#### 3. 网页排名
- 概念：在搜索网页时对搜索结果进行排序的算法
- 别名：佩奇排名
- 应用：谷歌的搜索引擎
- 思路：利用网页之间的链接结构计算出网页价值
- 图示流程
    - 基本原则：链入页面越多的网页，重要性也就越高；
    - 量化重要性的基本思路
        - 假设没有链入页面的网页权重为1；
        - 有链入页面的网页权重是其链入页面的权重之和；
        - 如果一个网页链向多个页面，那么其链向的所有页面将平分它的权重；
    - 问题
        - 链接结构为环状时，
            - 计算各个网页权重的操作会无限循环；
            - 环内网页的权重不断增长
    - 解决方案 
        - 随机游走模型
            - 思考：人们是怎样浏览网页的；
                - 从某个网页开始，通过链接浏览了几个网页，结束
                - 宏观视角：在有链接指向的页面之间移动几次之后，远程跳转到完全不相关的网页；
            - 定义用户浏览网页的操作：
                - 用户等概率跳转到当前网页所链向的一个网页的概率是1-\alpha,
                - 等概率远程跳转到其他网页中的一个网页的概率为\alpha。
            - 根据定义模拟网页间的跳转过程
                - 设置远程跳转概率\alpha; 
                - 总访问次数设置为1000次；
                - 模拟；
            - 该模型的特点
                - 就算网页链接结构为环状，也可以得出每个网页的权重；
            - 浏览次数换算成百分比，就是随机游走模型中网页的权重
                - 意义：某一刻正在浏览该网页的概率；
        - 确认网页排名的值和用链接加权计算的结果是否一致
            - 网页排名的机制：把权重替换为访问页面的概率来进行计算                   
- 小知识
    - 谷歌为什么要做免费的网络搜索服务？
    - 他们实际上是在做AI
- 解说
    - 搜索结果的排序顺序
        - 以前：关键词和网页内容的关联性
        - 缺点：没有考虑网页内是否含有有效内容，搜索精度较低；
        - 解决方案：使用网页排名算法
    - 网页排名算法的划时代意义
        - 利用网页链接结构计算出网页价值
        - 链接形成环状时也能进行计算        
    
#### 4. 汉诺塔
- 介绍
- 图示
    - 游戏规则
    - 移动条件
    - 步骤：
        - 1.只有2个圆盘的情况；
        - 2.3个圆盘的情况，忽略最大的，剩下的问题就是2个圆盘的情况；
    - 结论：
        - 不管需要移动多少圆盘，这个游戏最终都能达成目标；    
    - 证明：
        - 方法：数学归纳法
        - 思路：
            - 1.只有一个圆盘时，可以达成目标
            - 2.假设圆盘数量为n时，同样可以达成目标；
            - 3.圆盘数为n+1时，忽略最大的圆盘；圆盘数为n时可以达成目标；
- 解说
    - 概念
        - 递归：在算法描述中调用算法自身的方法；
    - 应用
        - 递归算法
        - 举例：归并排序，快速排序                
- 补充说明
    - 时间复杂度
        - 假设解决有n个圆盘的汉诺塔问题时需要的时间为T(n)；
        - 只有1个圆盘时只需要1步就能完成，T(1)=1；
        - 圆盘数为n时
            - 把上面的n-1个圆盘从A移动到B上需要时间T(n-1)；
            - 再把最大的圆盘移到C上需要1步；
            - 最后把B上的n-1个圆盘移到C上需要T(n-1)；
            - T(n)=2T(n-1)+1；
            - T(n)=2^n-1
              

