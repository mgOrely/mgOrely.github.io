---
layout: post
title: "丁奇的MySQL基础课"
description: "丁奇的MySQL基础课"
keywords: "mysql"
category: "mysql"
tags: [mysql]
---

## I 前言
* 来源：汪正邀请
* 平台：微信小程序：极客时间
* 形式：文章
* 开始时间：2019-08-15
* 结束时间：2019-08-23
* 阅读进度：
* 阅读时长：
* 感受：
    - 从一个问题出发，围绕这个问题，讲清楚相关的知识点；
    

## 文章
### 1. 基础架构：一条SQL查询语句是如何执行的？
### 2. 事务隔离：一条SQL更新语句是如何执行的？
### 3. 事务隔离：为什么你改了我还看不见？
#### 举例
- 转账过程
- 转账过程具体到程序里的一系列操作

#### 事务的简单介绍
- 概念：
- 作用：保证一组数据库操作，要么全部成功，要么全部失败；
- 实现：在MySQL中，事务支持是在引擎层实现的
    - MySQL原生的MyISAM引擎不支持事务
    - InnoDB引擎支持事务
    
#### 隔离性与隔离级别
- 数据库事务正确执行的四个基本要素：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性 （Durability）  
- 隔离级别
    - 概念的引出：为了解决数据库上有多个事务同时执行的时候，可能出现的问题：
        - 脏读（dirty read）
        - 不可重复读（non-repeatable read）
        - 幻读（phantom read）
    - 设置隔离级别的注意事项
        - 隔离得越严实，效率越低
        - 需要在隔离性和效率之间寻找一个平衡点
- SQL标准的事务隔离级别
    - 读未提交（read uncommitted）
        - 一个事务还没提交时，它做的变更就能被别的事务看到。
    - 读提交（read committed）
        - 一个事务提交后，它做的事务才会被别的事务看到。
    - 可重复读（repeatable read）
        - 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
        - 未提交变更对其他事务不可见。
    - 串行化（serializable）
        - 对于同一行记录，写会加写锁，读会加读锁；
        - 当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 
- 举例说明四种隔离级别
    - 假设数据表
    - 假设按照时间顺序执行两个事务的行为
    - 分析在不同的隔离级别下，事务的返回结果
- 隔离级别的实现
    - 数据库里面创建一个视图，访问的时候以视图的逻辑结果为准。
        - 不同隔离级别下，视图的创建时机
            - 读提交：在每个SQL语句开始执行的时候创建； ？？？
            - 可重复读：在事务启动时创建，整个事务存在期间都用这个视图；        
    - 读未提交：直接返回记录上的最新值，没有视图概念；
    - 串行化：直接用加锁的方式来避免并行访问；
- 数据库的默认隔离级别
    - Oracle默认是 `读提交`
    - 注意：从Oracle迁移到MySQL，保证数据库隔离级别的一致；
- 隔离级别的配置
    - 将启动参数transaction-isolation的值设置成READ-COMMITTED
    - 查看当前的值：`show variables like 'transaction-isolation' `           
- 不同隔离级别的使用场景
    - 可重复读
        - 案例：数据校对逻辑
        - 场景：事务启动时的视图是静态的，不受其他事务更新的影响；
        
#### 事务隔离的实现
- MySQL的更新机制
    - 在MySQL中，每条记录在更新的时候，都会同时记录一条回滚操作。
    - 记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
    - 查询一条记录的时候，不同时刻启动的事务会有不同的read-view。
- 举例
- 数据库的多版本并发控制（MVCC）
    - 同一条记录在系统中可以存在多个版本；
- 什么时候删除回滚日志
    - 系统判断当没有事务再需要用到这些回滚日志的时候，回滚日志会被删除
    - 具体就是当系统里没有比这个回滚日志更早的read-view的时候；    
- 为什么建议你尽量不要使用长事务
    - 大量占用存储空间
        - 长事务意味着系统里面会存在很老的事务视图；
        - 这些事务随时可能访问数据库里面的任何数据，所以在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间；    
        - 举例
            - MySQL5.5及以前的版本，回滚日志跟数据字典一起放在ibdata文件；
            - 即使长事务最终提交，回滚段被清理，文件也不会变小。
        - 案例
            - 数据20G，回滚段200G；
            - 清理回滚段的解决方案：重建整个库    
    - 占用锁资源，可能拖垮整个库
    
#### 事务的启动方式   
- 显示启动事务语句：set autocommit=1
    - begin或start transaction
    - 配套的提交语句是commit
    - 回滚语句是rollback
    - 查看数据库的事务 `show variables like 'autocommit'`，发现是ON；
    - 建议解决方案：在需要频繁使用事务的业务中，提交事务并自动启动下一个事务`commit work and chain`
        - 好处：
            - 省去了再次执行begin语句的开销；
            - 从程序开发的角度明确地知道每个语句是否处于事务中；
        
- set autocommit=0
    - 这个命令会将这个线程的自动提交关掉；
    - 意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。
    - 这个事务持续存在，直到你主动执行commit或rollback语句，或者断开连接。
    - 注意：有的客户端连接框架会默认连接成功后先执行一个set autocommit=0命令
        - 导致接下来的查询都在事务中
        - 如果是长连接，就导致了意外的长事务
    - 查询长事务：information_schema库的innodb_trx表
        - 查找持续时间超过60s的长事务 
            ```sql
            SELECT * FROM `information_schema`.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60          
            ```
    - 适用场景：需要频繁使用事务的业务；
        - 每个事务在开始时，都不需要主动执行一次begin，减少了语句的交互次数；
  
#### 小结
- MySQL事务隔离级别的现象和实现
- 根据实现原理分析了长事务存在的风险
- 如何用正确的方式避免长事务
- 问题：如何避免长事务？       
           
### 4. 事务隔离：深入浅出索引（上）


### 5. 事务隔离：深入浅出索引（下）

### 6. 事务隔离：全局锁和表锁：给表加个字段怎么这么多阻碍？